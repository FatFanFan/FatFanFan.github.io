<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>理解 JavaScript 中的 this</title>
    <link href="/2020/04/19/%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%20this/"/>
    <url>/2020/04/19/%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%20this/</url>
    
    <content type="html"><![CDATA[<h2 id="必知"><a href="#必知" class="headerlink" title="必知"></a>必知</h2><blockquote><p>this 实际上是在函数被调用时发生的绑定，它指向哪里完全取决于函数在哪里被调用。</p></blockquote><h3 id="大提示-不想看分析的可以直接拉到最后看结论。"><a href="#大提示-不想看分析的可以直接拉到最后看结论。" class="headerlink" title="大提示: 不想看分析的可以直接拉到最后看结论。"></a>大提示: 不想看分析的可以直接拉到最后看结论。</h3><h3 id="面试常见题"><a href="#面试常见题" class="headerlink" title="面试常见题"></a>面试常见题</h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;  a :<span class="hljs-number">2</span>,  foo:foo&#125;<span class="hljs-keyword">var</span> bar = obj.fooobj.foo() bar()</code></pre><p>问： 最后两个打印出什么？</p><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;  a :<span class="hljs-number">2</span>,  foo:foo&#125;<span class="hljs-keyword">var</span> obj2 = &#123;  a:<span class="hljs-number">1</span>,  obj:obj&#125;<span class="hljs-keyword">var</span> obj3 = obj2.obj.fooobj2.obj.foo() <span class="hljs-comment">// 2</span>obj3() <span class="hljs-comment">//undefined</span></code></pre><p>问： 最后两个打印出什么？<br>答？</p><h2 id="我们如何理解-this-绑定的到底是谁？或者说-this-到底是谁？下面介绍四种方法"><a href="#我们如何理解-this-绑定的到底是谁？或者说-this-到底是谁？下面介绍四种方法" class="headerlink" title="我们如何理解 this 绑定的到底是谁？或者说 this 到底是谁？下面介绍四种方法"></a>我们如何理解 this 绑定的到底是谁？或者说 this 到底是谁？下面介绍四种方法</h2><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h3><p> 什么是默认绑定呢？上代码先</p><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-meta">  'use strict'</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;foo() <span class="hljs-comment">// 2</span>foo2() <span class="hljs-comment">//  TypeError: Cannot read property 'a' of undefined</span></code></pre><ul><li>在上面的代码中，「 foo() 直接使用时不带任何修饰的函数引用进行调用的 」，<br>因此只能使用「默认绑定」</li><li>所以到 foo() 中的 this 绑定到「 全局对象 window 」，而「 严格模式 」时，全局对象无法被绑定，所以 this 绑定到  「undefined」</li></ul><p><strong>默认绑定总结：默认绑定即不带任何修饰的函数引用被调用时的绑定，此时 this 绑定到「 全局对象 window 」或者 「undefined」</strong></p><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h3><h4 id="隐式绑定是什么呢？隐式的绑定"><a href="#隐式绑定是什么呢？隐式的绑定" class="headerlink" title="隐式绑定是什么呢？隐式的绑定"></a>隐式绑定是什么呢？隐式的绑定</h4><blockquote><p>当函数引用有上下文对象时，隐式绑定会把函数调用中的 this 绑定到这个上下文对象。</p></blockquote><p><strong>那么回到面试题</strong></p><h4 id="2-1-面试题一"><a href="#2-1-面试题一" class="headerlink" title="2.1 面试题一"></a>2.1 面试题一</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span> :<span class="hljs-number">2</span>,  <span class="hljs-attr">foo</span>:foo &#125;<span class="hljs-keyword">var</span> bar = obj.fooobj.foo() <span class="hljs-comment">//2</span>bar()  <span class="hljs-comment">// undefined</span></code></pre><p>foo() 被调用时，落脚点指向 obj 对象（上下文对象），所以 this 绑定到 obj  ，this.a 即 obj.a , 所以打印出了 2</p><p><strong>但是为什么 bar() 打印出了 <code>undefined</code> 呢？</strong></p><p>虽然 bar 是 obj.foo 的引用，但实际上是 foo函数 本身的引用，所以此时 bar() 是不带任何修饰的函数调用，使用默认调用</p><h4 id="2-2-面试题二"><a href="#2-2-面试题二" class="headerlink" title="2.2 面试题二"></a>2.2 面试题二</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;<span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">a</span> :<span class="hljs-number">2</span>,  <span class="hljs-attr">foo</span>:foo  &#125;<span class="hljs-keyword">var</span> obj2 = &#123;  <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,  <span class="hljs-attr">obj</span>:obj   &#125;<span class="hljs-keyword">var</span> obj3 = obj2.obj.fooobj2.obj.foo() <span class="hljs-comment">// 2</span>obj3() <span class="hljs-comment">//undefined</span></code></pre><p>跟上面一题相同，虽然引用链比较长，但是最后 foo() 是在 obj 中被调用，所以 <code>this</code> 绑定到 obj ，引用链只有最后一层影响调用位置。</p><h4 id="隐式绑定总结-：-函数在上下文对象中调用时，-this-绑定到-上下文对象上。"><a href="#隐式绑定总结-：-函数在上下文对象中调用时，-this-绑定到-上下文对象上。" class="headerlink" title="隐式绑定总结  ： 函数在上下文对象中调用时， this 绑定到 上下文对象上。"></a>隐式绑定总结  ： 函数在上下文对象中调用时， this 绑定到 上下文对象上。</h4><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h3><blockquote><p>使用「 call apply bind 」 进行绑定 this , this 绑定到第一个传入的参数</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#" target="_blank" rel="noopener">MDN三者的用法</a></p><h4 id="3-1-call-的使用"><a href="#3-1-call-的使用" class="headerlink" title="3.1  call 的使用"></a>3.1  call 的使用</h4><p>回到面试题第一题，我们使用「 call 」进行显式绑定</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;<span class="hljs-keyword">var</span> obj = &#123;  a :<span class="hljs-number">2</span>,  foo:foo&#125;<span class="hljs-keyword">var</span> bar =obj.fooobj.foo() <span class="hljs-comment">// 2</span>bar.call(obj) <span class="hljs-comment">//2</span></code></pre><p>此时两者都打印出 2 ，因为我们将 this 绑定到 obj ，打印出的即是  //obj.a  //2</p><h4 id="3-2-apply-绑定第一个参数是-this-二参是-一个数组"><a href="#3-2-apply-绑定第一个参数是-this-二参是-一个数组" class="headerlink" title="3.2 apply  绑定第一个参数是 this , 二参是 一个数组"></a>3.2 apply  绑定第一个参数是 this , 二参是 一个数组</h4><h4 id="3-3-bind-是-绑定第一个参数是-this"><a href="#3-3-bind-是-绑定第一个参数是-this" class="headerlink" title="3.3 bind 是 绑定第一个参数是 this"></a>3.3 bind 是 绑定第一个参数是 this</h4><h4 id="显式绑定总结-使用call-apply-bind-时，第一个参数是-this-，不传的话，默认为-undefined-。"><a href="#显式绑定总结-使用call-apply-bind-时，第一个参数是-this-，不传的话，默认为-undefined-。" class="headerlink" title="显式绑定总结: 使用call  apply bind 时，第一个参数是 this ，不传的话，默认为 undefined  。"></a>显式绑定总结: 使用call  apply bind 时，第一个参数是 this ，不传的话，默认为 undefined  。</h4><h3 id="4-new-绑定"><a href="#4-new-绑定" class="headerlink" title="4. new 绑定"></a>4. new 绑定</h3><h5 id="使用-new-来调用函数，-到底做了什么-？"><a href="#使用-new-来调用函数，-到底做了什么-？" class="headerlink" title="使用 new 来调用函数， 到底做了什么 ？"></a>使用 new 来调用函数， 到底做了什么 ？</h5><ul><li><ol><li>创建一个全新的对象</li></ol></li><li><ol start="2"><li>这个新对象的<code>__proto__</code> 链接到 构造函数的 <code>prototype</code> </li></ol></li><li><ol start="3"><li>这个新对象会绑定到函数调用的 this</li></ol></li><li><ol start="4"><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。<pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>&#123;  <span class="hljs-keyword">this</span>.a = a &#125;<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(bar.a) <span class="hljs-comment">// 2</span></code></pre>分析： 使用 new 调用 foo() 时，我们构造一个对象并把它绑定到 foo() 调用的 <code>this</code> 上</li></ol></li></ul><p>####new 绑定总结：  new 绑定中 this 绑定的就是新生成的对象</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.「 箭头函数 」内的 <code>this</code> 就是外面的 <code>this</code>  ，外面的 <code>this</code> 是啥看下面四条</p><p>2.「 <code>new</code> 绑定 」函数是否在 <code>new</code> 中调用 ？ 如果是 <code>this</code> 绑定的即是 新创建的对象。<br><code>var bar = new foo()</code></p><p>3.「 显式绑定 」函数是否通过 call 、apply、 bind 绑定？<code>this</code> 绑定的时第一个参数<br><code>var bar = foo.call(obj)</code></p><p>4.「 隐式绑定 」 函数是否在某个上下文中调用？ 是的话，<code>this</code> 绑定的是那个上下文对象<br><code>var bar =  obj.foo()</code></p><p>5.「 默认绑定」如果都不是，那么就是默认绑定。严格模式绑定到 <code>undefined</code> ，否则绑定到 全局对象<br><code>var bar = foo()</code></p><p><strong>后记</strong></p><p>你要是看不懂我也没办法了，我的修为都在这了。。。。</p><p>文章为个人总结，不足之处还请私信。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux 简单使用</title>
    <link href="/2020/04/17/redux%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/04/17/redux%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p><strong>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> store = createStore(counter);</code></pre><ol><li><p>state <code>const state = store.getState()</code></p><p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。<br>你知道 State，就知道 View 是什么样，反之亦然。</p></li><li><p>dispatch</p><p>store.dispatch() 接受一个 Action 对象，将它分发出去</p></li><li><p>subscribe</p><p>Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p><p>store.subscribe 方法返回一个函数，调用这个函数就可以解除监听。</p></li></ol><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p><strong>描述发生了什么</strong></p><pre><code class="hljs plain">&#123;  type: &quot;ADD&quot;;&#125;</code></pre><h2 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h2><p><strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</strong></p><p><strong>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) </span>&#123;  <span class="hljs-keyword">switch</span> (action.type) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">"ADD"</span>:      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;    <span class="hljs-keyword">case</span> <span class="hljs-string">"MINUS"</span>:      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span> state;  &#125;&#125;</code></pre><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>首先，用户发出 Action。</p><p><code>store.dispatch(action);</code></p><p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。<br>Reducer 会返回新的 State 。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> nextState = counter(previousState, action);</code></pre><p>State 一旦有变化，Store 就会调用监听函数。</p><p>// 设置监听函数<br>结合 React 的 hooks 可以更新数据</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [number, setNumber] = useState(store.getState());store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setNumber(store.getState()));</code></pre><p><a href="https://codesandbox.io/s/ts-redux-l2r9n?file=/src/App.tsx" target="_blank" rel="noopener">加减示例</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>React Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
