<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>用 Node.js 写个命令行翻译工具, 发布到 npm</title>
    <link href="/2020/05/27/fanyi/"/>
    <url>/2020/05/27/fanyi/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h2><h3 id="1-1-项目环境配置"><a href="#1-1-项目环境配置" class="headerlink" title="1.1 项目环境配置"></a>1.1 项目环境配置</h3><ul><li>创建一个空目录 <code>node_fanyi</code></li><li>初始化 <code>yarn init -y</code></li><li>全局安装 ts-node-dev <code>yarn global add ts-node-dev</code> ，<br>这个工具是用来支持 <code>typescript</code> 进行 <code>node</code> 开发</li><li>全局安装 typescript <code>yarn global add typescript</code>，支持 ts 开发,<br>用于将 ts 编译成 js, 用于最后发布 <code>npm</code> 包</li><li>用 webstorm 或 vscode 打开 <code>node_fanyi</code></li><li>安装 node 声明文件 <code>yarn add --dev @types/node</code></li></ul><h3 id="1-2-环境测试"><a href="#1-2-环境测试" class="headerlink" title="1.2 环境测试"></a>1.2 环境测试</h3><ul><li><p>在 <code>node_fanyi</code> 目录下 创建 <code>src/cli.ts</code> 并写入如下代码</p>  <pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ts-node-dev can run"</span>)</code></pre></li><li><p>命令行运行 <code>ts-node-dev  src/cli.ts</code> , 命令行打出  <code>ts-node-dev can run</code> </p></li><li><p>命令行运行  <code>tsc -v</code>  打印出 ts 的版本号</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/27/1725412d49589ae0?w=573&h=156&f=png&s=10129" srcset="/img/loading.gif" alt=""></p><h2 id="2-如何处理命令行参数"><a href="#2-如何处理命令行参数" class="headerlink" title="2. 如何处理命令行参数"></a>2. 如何处理命令行参数</h2><h3 id="2-1-commander-js"><a href="#2-1-commander-js" class="headerlink" title="2.1 commander.js"></a>2.1 commander.js</h3><blockquote><p>commander.js , node.js 命令行接口的完整解决方案</p></blockquote><p>使用 commander.js 来快速进行命令行工具开发</p><p><a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander.js 文档</a></p><pre><code class="hljs yarn">yarn add commander</code></pre><h3 id="2-2-用法简介"><a href="#2-2-用法简介" class="headerlink" title="2.2 用法简介"></a>2.2 用法简介</h3><p>在 <code>node_fanyi</code> 下创建 <code>src/cli.js</code>, 引入 <code>commander</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> commander <span class="hljs-keyword">from</span> <span class="hljs-string">"commander"</span>;<span class="hljs-keyword">const</span> program = <span class="hljs-keyword">new</span> commander.Command();program  .version(<span class="hljs-string">"0.0.1"</span>)  .name(<span class="hljs-string">"fy"</span>)  .usage(<span class="hljs-string">"&lt;English&gt;"</span>)  .arguments(<span class="hljs-string">"&lt;English&gt;"</span>)  .action(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(word);  &#125;);program.parse(process.argv);</code></pre><ul><li>version  参数-版本号 </li><li>name  参数-使用的命令  </li><li>usage 参数-可选/必选参数名</li><li>arguments 参数-必传命令后的入参 </li><li>action 参数-回调函数  </li></ul><p>运行 <code>ts-node-dev src/cli.ts -h</code></p><p><img src="https://user-gold-cdn.xitu.io/2020/5/27/17254200ba5092dd?w=635&h=200&f=png&s=15537" srcset="/img/loading.gif" alt=""></p><p>通过 action 可以拿到传入的参数, <code>ts-node-dev src/cli.ts add</code><br>命令行打印出传入的参数</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/27/1725422f113c452c?w=616&h=91&f=png&s=6542" srcset="/img/loading.gif" alt=""><br>在 <code>src</code> 中新建 <code>main.ts</code> 写入下面的代码</p><pre><code class="hljs plain">export const translate &#x3D; (word: string) &#x3D;&gt; &#123;    console.log(word)    &#x2F;&#x2F; do something 这里用来将传入的 word 翻译之后打印出来&#125;</code></pre><p>在 <code>src/cli.ts</code> 引入 , 在 <code>action</code> 的回调函数里调用 <code>translate</code> 函数</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; translate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./main"</span>;program  .version(<span class="hljs-string">"0.0.1"</span>)  .name(<span class="hljs-string">"fy"</span>)  .usage(<span class="hljs-string">"&lt;English||中文&gt;"</span>)  .arguments(<span class="hljs-string">"&lt;English||中文&gt;"</span>)  .action(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) </span>&#123;    translate(word);  &#125;);</code></pre><p>下一步进行翻译函数的逻辑书写</p><h2 id="3-翻译"><a href="#3-翻译" class="headerlink" title="3. 翻译"></a>3. 翻译</h2><h3 id="3-1-https-request-发送翻译请求"><a href="#3-1-https-request-发送翻译请求" class="headerlink" title="3.1 https.request 发送翻译请求"></a>3.1 https.request 发送翻译请求</h3><p>修改 <code>main.js</code> 代码如下,测试<code>https.request</code>能否发送 GET 请求</p><pre><code class="hljs plain">import * as https from &quot;https&quot;;export const translate &#x3D; (word: string) &#x3D;&gt; &#123;  const options &#x3D; &#123;    hostname: &quot;www.baidu.com&quot;,    port: 443,    method: &quot;GET&quot;,  &#125;;  const request &#x3D; https.request(options, (response) &#x3D;&gt; &#123;    response.on(&quot;data&quot;, (chunk: Buffer) &#x3D;&gt; &#123;      console.log(chunk);     &#125;);    response.on(&quot;end&quot;, () &#x3D;&gt; &#123;      console.log(&quot;end&quot;);    &#125;);  &#125;);  request.on(&quot;error&quot;, (e) &#x3D;&gt; &#123;    console.error(e);  &#125;);  request.end();&#125;;&#96;&#96;&#96; 命令行运行 &#96;ts-node-dev src&#x2F;cli.ts add&#96;，正确运行，会打印出 &#96;chunk&#96; &#96;end&#96;![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;5&#x2F;27&#x2F;17254d5d1da5775d?w&#x3D;1390&amp;h&#x3D;336&amp;f&#x3D;png&amp;s&#x3D;46980)进行到这里我们只需要接入翻译 API，使用 API 翻译拿到的命令行参数就可以了### 3.2 翻译 API 获取与使用#### 3.2.1 获取你可以使用百度翻译或有道翻译的API，我选择了百度翻译的API，你可以自己选择使用哪个。[百度翻译](https:&#x2F;&#x2F;api.fanyi.baidu.com&#x2F;)[有道翻译](http:&#x2F;&#x2F;fanyi.youdao.com&#x2F;openapi)在官网进行登录过之后，点击产品服务，通用翻译 API, 点击立即使用，一般使用标准版就足够![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;5&#x2F;27&#x2F;17254e07cc7ef143?w&#x3D;1310&amp;h&#x3D;755&amp;f&#x3D;png&amp;s&#x3D;88500)点击接入文档，里面有接口、输入参数、返回值、语言列表、错误码、查看接入举例**注意 不要泄露你的 appid 以及 appSecret**查询参数&#96;&#96;&#96;Javascript &#x2F;**   * salt 随机数   * sign 文档中生成签名的方式 appSecret 可以在开发者信息中看到   * 使用 querystring.stringify() 把这些查询参数拼接成字符串   * appid  在开发者信息里可以看到   *&#x2F;      const salt &#x3D; Math.random();  const sign &#x3D; md5(appId + word + salt + appSecret);  const query &#x3D; querystring.stringify(&#123;    q: word, &#x2F;&#x2F; 需要查询的单词    appid: appId,    salt,  &#x2F;&#x2F; 随机数    sign, &#x2F;&#x2F; 生成的签名    from:&quot;en&quot;, &#x2F;&#x2F; 输入的语言    to:&quot;zh&quot;,  &#x2F;&#x2F; 输出的语言  &#125;);</code></pre><p>接口  文档中的接口</p><pre><code class="hljs plain">const options &#x3D; &#123;  hostname: &quot;api.fanyi.baidu.com&quot;,  port: 443,  path: &quot;&#x2F;api&#x2F;trans&#x2F;vip&#x2F;translate?&quot; + query,   &#x2F;&#x2F; query 即为上文的参训参数生成的 query  method: &quot;GET&quot;,&#125;;</code></pre><h4 id="3-2-2-使用-API"><a href="#3-2-2-使用-API" class="headerlink" title="3.2.2 使用 API"></a>3.2.2 使用 API</h4><p>新建 <code>src/private.ts</code> 写入代码并将这个文件加入到 <code>.gitignore</code> </p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> appId = <span class="hljs-string">""</span>; <span class="hljs-comment">// 你申请的 appid</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> appSecret = <span class="hljs-string">""</span>; <span class="hljs-comment">// 你申请的 appSecret</span></code></pre><p>在 <code>mian.js</code> 中引入 <code>private.ts</code><br>安装 md5 以及其声明文件 <code>yarn add md5</code> <code>yarn add --dev @types/md5</code></p><p><code>main.ts</code> 完整代码<br><a href="https://github.com/fatfanfan/node_fanyi" target="_blank" rel="noopener">命令行翻译 源代码</a>  </p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> https <span class="hljs-keyword">from</span> <span class="hljs-string">"https"</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> querystring <span class="hljs-keyword">from</span> <span class="hljs-string">"querystring"</span>;<span class="hljs-keyword">import</span> &#123; appId, appSecret &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./private"</span>;<span class="hljs-keyword">import</span> md5 <span class="hljs-keyword">from</span> <span class="hljs-string">"md5"</span>;<span class="hljs-keyword">type</span> ErrorMap = &#123;  [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;&#125;;<span class="hljs-keyword">const</span> errorMap: ErrorMap = &#123;  <span class="hljs-number">52003</span>: <span class="hljs-string">"用户认证失败"</span>,  <span class="hljs-number">54001</span>: <span class="hljs-string">"签名错误"</span>,  <span class="hljs-number">54004</span>: <span class="hljs-string">"账户余额不足"</span>,&#125;;<span class="hljs-keyword">type</span> BaiduResult = &#123;  error_code?: <span class="hljs-built_in">string</span>;  error_msg?: <span class="hljs-built_in">string</span>;  <span class="hljs-keyword">from</span>: <span class="hljs-built_in">string</span>;  to: <span class="hljs-built_in">string</span>;  trans_result: &#123; src: <span class="hljs-built_in">string</span>; dst: <span class="hljs-built_in">string</span> &#125;[];&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> translate = <span class="hljs-function">(<span class="hljs-params">word: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> salt = <span class="hljs-built_in">Math</span>.random();  <span class="hljs-keyword">const</span> sign = md5(appId + word + salt + appSecret);  <span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span>, to;  <span class="hljs-comment">// 判断输入的是中文/英文</span>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[a-zA-Z]/</span>.test(word[<span class="hljs-number">0</span>])) &#123;    <span class="hljs-keyword">from</span> = <span class="hljs-string">"en"</span>;    to = <span class="hljs-string">"zh"</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">from</span> = <span class="hljs-string">"zh"</span>;    to = <span class="hljs-string">"en"</span>;  &#125;  <span class="hljs-keyword">const</span> query = querystring.stringify(&#123;    q: word,    appid: appId,    salt,    sign,    <span class="hljs-keyword">from</span>,    to,  &#125;);  <span class="hljs-keyword">const</span> options = &#123;    hostname: <span class="hljs-string">"api.fanyi.baidu.com"</span>,    port: <span class="hljs-number">443</span>,    path: <span class="hljs-string">"/api/trans/vip/translate?"</span> + query,    method: <span class="hljs-string">"GET"</span>,  &#125;;  <span class="hljs-keyword">const</span> request = https.request(options, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-comment">//监听data 事件， 有返回值就放到 chunks 中</span>    <span class="hljs-keyword">let</span> chunks: Buffer[] = [];    response.on(<span class="hljs-string">"data"</span>, <span class="hljs-function">(<span class="hljs-params">chunk: Buffer</span>) =&gt;</span> &#123;      chunks.push(chunk);    &#125;);    <span class="hljs-comment">// end 之后，将获取到的 chunks 转换成 我们熟悉的 object</span>    <span class="hljs-comment">// 然后对对象进行解析，判断成功或者失败</span>    <span class="hljs-comment">// 失败打印出 errMsg</span>    <span class="hljs-comment">// 成功就在命令行中打印出翻译后的结果</span>    response.on(<span class="hljs-string">"end"</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> = Buffer.concat(chunks).toString();      <span class="hljs-keyword">const</span> object: BaiduResult = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">string</span>);      <span class="hljs-keyword">if</span> (object.error_code) &#123;        <span class="hljs-built_in">console</span>.error(errorMap[object.error_code] || object.error_msg);        process.exit(<span class="hljs-number">2</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        object.trans_result.map(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(obj.dst);        &#125;);        process.exit(<span class="hljs-number">0</span>);      &#125;    &#125;);  &#125;);  request.on(<span class="hljs-string">"error"</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.error(e);  &#125;);  request.end();&#125;;</code></pre><p>运行 <code>ts-node-dev src/cli.ts add</code> </p><p><code>ts-node-dev src/cli.ts 成功</code></p><p>示例如下<br><img src="https://user-gold-cdn.xitu.io/2020/5/27/1725513657c3b374?w=627&h=184&f=png&s=13883" srcset="/img/loading.gif" alt=""></p><p>基本上到这里就结束了，如果你想发布到 npm ，请继续</p><h2 id="4-发布到-npm"><a href="#4-发布到-npm" class="headerlink" title="4. 发布到 npm"></a>4. 发布到 npm</h2><h3 id="4-1-注册-npm"><a href="#4-1-注册-npm" class="headerlink" title="4.1 注册 npm"></a>4.1 注册 npm</h3><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm 官网</a><br>自己去注册</p><h3 id="4-2-将-ts-转换-js"><a href="#4-2-将-ts-转换-js" class="headerlink" title="4.2 将 ts 转换 js"></a>4.2 将 ts 转换 js</h3><ul><li>命令行运行 <code>tsc -- init</code> 生成 <code>tsconfig.json</code>文件</li><li>修改 tsconfig.json 文件中的  “outDir”: “dist/“   // tsc 编译 ts 生成 js 的文件夹</li><li>运行 <code>tsc</code> 生成 dist 目录以及 ts 文件对应的 js 文件 </li><li>将 <code>dist/private.js</code> 加入到 <code>.gitignore</code></li></ul><h3 id="4-3-修改-package-json"><a href="#4-3-修改-package-json" class="headerlink" title="4.3 修改 package.json"></a>4.3 修改 package.json</h3><p>最终代码在最后的源码链接中</p><pre><code class="hljs plain">&#123;  &quot;name&quot;: &quot;node_fanyi&quot;,  &#x2F;&#x2F; 你的 npm 包的名称 注意可能出现与别人的包重名 换一个就好了  &quot;version&quot;: &quot;0.0.1&quot;,    &#x2F;&#x2F; 你的包的版本 每次发布都要改版  &quot;main&quot;: &quot;dist&#x2F;main.js&quot;, &#x2F;&#x2F; 加载的入口文件   &quot;bin&quot;: &#123;               &#x2F;&#x2F; 指定各个内部命令对应的可执行文件的位置    &quot;fy&quot;: &quot;dist&#x2F;cli.js&quot;   &#x2F;&#x2F; 默认的命令 fy   &#125;,  &quot;files&quot;: [             &#x2F;&#x2F; 要上传的文件    &quot;dist&#x2F;**&#x2F;*.js&quot;  ],&#125;</code></pre><h3 id="4-4-生成代码并发布"><a href="#4-4-生成代码并发布" class="headerlink" title="4.4 生成代码并发布"></a>4.4 生成代码并发布</h3><ul><li><ol><li>运行 <code>tsc</code>  每次发布前都要运行 <code>tsc</code> 重新生成 <code>dist</code></li></ol></li><li><ol start="2"><li>npm 换成官方源，非官方源不能发布 依次运行 <code>npm install nrm -g</code>   <code>nrm use npm</code></li></ol></li><li><ol start="3"><li>运行 <code>npm adduser</code>  登录 npm ,根据提示填写「 username password email 」</li></ol></li><li><ol start="4"><li>运行 <code>npm publish</code>  发布代码</li></ol></li></ul><h2 id="5-可能出现的问题以及其他提示"><a href="#5-可能出现的问题以及其他提示" class="headerlink" title="5. 可能出现的问题以及其他提示"></a>5. 可能出现的问题以及其他提示</h2><ol><li><p>你没用过 ts ？</p><p> 把 ts 后缀改为 js 就好了，去掉声明</p></li><li><p>代码报错？</p><p> 把源代码复制到你的代码中，看看能不能跑起来</p></li><li><p>发布不成功?</p><p> 没换官方源</p><p> version 没修改版本号</p><p> name 跟别人已发布的相同</p></li></ol><ol start="4"><li><p>其他 ?</p><p> 我也不知道了。。。有其他问题联系我吧</p></li></ol><h2 id="6-安全问题以及其他"><a href="#6-安全问题以及其他" class="headerlink" title="6. 安全问题以及其他"></a>6. 安全问题以及其他</h2><ol><li><p>不要暴露 appid 以及 appSecret 不然别人可以用你的 appid 和 appSecret 干些其他的，尽量只开通标准版</p></li><li><p>目前只有简单的单个单词和中文句子的翻译，后续可能还会加功能。。。</p></li><li><p>体验我已经发布的命令行翻译工具 如果不行就是我已经停用我的百度翻译API 服务了</p></li></ol><pre><code class="hljs plain">npm install fanyi-f -g</code></pre><pre><code class="hljs plain">fy add</code></pre><h2 id="7-源码"><a href="#7-源码" class="headerlink" title="7. 源码"></a>7. 源码</h2><p><a href="https://github.com/fatfanfan/node_fanyi" target="_blank" rel="noopener">命令行翻译 源代码</a>    </p><p>后记</p><p>文章为个人总结，不足之处还请留言或私信。</p><p>转载请注明出处。</p><p>以上。    </p>]]></content>
    
    
    
    <tags>
      
      <tag>node.js typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 JavaScript 中的 this</title>
    <link href="/2020/05/27/%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%20this/"/>
    <url>/2020/05/27/%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%20this/</url>
    
    <content type="html"><![CDATA[<h2 id="必知"><a href="#必知" class="headerlink" title="必知"></a>必知</h2><blockquote><p>this 实际上是在函数被调用时发生的绑定，它指向哪里完全取决于函数在哪里被调用。</p></blockquote><h3 id="大提示-不想看分析的可以直接拉到最后看结论。"><a href="#大提示-不想看分析的可以直接拉到最后看结论。" class="headerlink" title="大提示: 不想看分析的可以直接拉到最后看结论。"></a>大提示: 不想看分析的可以直接拉到最后看结论。</h3><h3 id="面试常见题"><a href="#面试常见题" class="headerlink" title="面试常见题"></a>面试常见题</h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;  a :<span class="hljs-number">2</span>,  foo:foo&#125;<span class="hljs-keyword">var</span> bar = obj.fooobj.foo() bar()</code></pre><p>问： 最后两个打印出什么？</p><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;  a :<span class="hljs-number">2</span>,  foo:foo&#125;<span class="hljs-keyword">var</span> obj2 = &#123;  a:<span class="hljs-number">1</span>,  obj:obj&#125;<span class="hljs-keyword">var</span> obj3 = obj2.obj.fooobj2.obj.foo() <span class="hljs-comment">// 2</span>obj3() <span class="hljs-comment">//undefined</span></code></pre><p>问： 最后两个打印出什么？<br>答？</p><h2 id="我们如何理解-this-绑定的到底是谁？或者说-this-到底是谁？下面介绍四种方法"><a href="#我们如何理解-this-绑定的到底是谁？或者说-this-到底是谁？下面介绍四种方法" class="headerlink" title="我们如何理解 this 绑定的到底是谁？或者说 this 到底是谁？下面介绍四种方法"></a>我们如何理解 this 绑定的到底是谁？或者说 this 到底是谁？下面介绍四种方法</h2><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h3><p> 什么是默认绑定呢？上代码先</p><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-meta">  'use strict'</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;foo() <span class="hljs-comment">// 2</span>foo2() <span class="hljs-comment">//  TypeError: Cannot read property 'a' of undefined</span></code></pre><ul><li>在上面的代码中，「 foo() 直接使用时不带任何修饰的函数引用进行调用的 」，<br>因此只能使用「默认绑定」</li><li>所以到 foo() 中的 this 绑定到「 全局对象 window 」，而「 严格模式 」时，全局对象无法被绑定，所以 this 绑定到  「undefined」</li></ul><p><strong>默认绑定总结：默认绑定即不带任何修饰的函数引用被调用时的绑定，此时 this 绑定到「 全局对象 window 」或者 「undefined」</strong></p><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h3><h4 id="隐式绑定是什么呢？隐式的绑定"><a href="#隐式绑定是什么呢？隐式的绑定" class="headerlink" title="隐式绑定是什么呢？隐式的绑定"></a>隐式绑定是什么呢？隐式的绑定</h4><blockquote><p>当函数引用有上下文对象时，隐式绑定会把函数调用中的 this 绑定到这个上下文对象。</p></blockquote><p><strong>那么回到面试题</strong></p><h4 id="2-1-面试题一"><a href="#2-1-面试题一" class="headerlink" title="2.1 面试题一"></a>2.1 面试题一</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span> :<span class="hljs-number">2</span>,  <span class="hljs-attr">foo</span>:foo &#125;<span class="hljs-keyword">var</span> bar = obj.fooobj.foo() <span class="hljs-comment">//2</span>bar()  <span class="hljs-comment">// undefined</span></code></pre><p>foo() 被调用时，落脚点指向 obj 对象（上下文对象），所以 this 绑定到 obj  ，this.a 即 obj.a , 所以打印出了 2</p><p><strong>但是为什么 bar() 打印出了 <code>undefined</code> 呢？</strong></p><p>虽然 bar 是 obj.foo 的引用，但实际上是 foo函数 本身的引用，所以此时 bar() 是不带任何修饰的函数调用，使用默认调用</p><h4 id="2-2-面试题二"><a href="#2-2-面试题二" class="headerlink" title="2.2 面试题二"></a>2.2 面试题二</h4><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;<span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">a</span> :<span class="hljs-number">2</span>,  <span class="hljs-attr">foo</span>:foo  &#125;<span class="hljs-keyword">var</span> obj2 = &#123;  <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,  <span class="hljs-attr">obj</span>:obj   &#125;<span class="hljs-keyword">var</span> obj3 = obj2.obj.fooobj2.obj.foo() <span class="hljs-comment">// 2</span>obj3() <span class="hljs-comment">//undefined</span></code></pre><p>跟上面一题相同，虽然引用链比较长，但是最后 foo() 是在 obj 中被调用，所以 <code>this</code> 绑定到 obj ，引用链只有最后一层影响调用位置。</p><h4 id="隐式绑定总结-：-函数在上下文对象中调用时，-this-绑定到-上下文对象上。"><a href="#隐式绑定总结-：-函数在上下文对象中调用时，-this-绑定到-上下文对象上。" class="headerlink" title="隐式绑定总结  ： 函数在上下文对象中调用时， this 绑定到 上下文对象上。"></a>隐式绑定总结  ： 函数在上下文对象中调用时， this 绑定到 上下文对象上。</h4><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h3><blockquote><p>使用「 call apply bind 」 进行绑定 this , this 绑定到第一个传入的参数</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#" target="_blank" rel="noopener">MDN三者的用法</a></p><h4 id="3-1-call-的使用"><a href="#3-1-call-的使用" class="headerlink" title="3.1  call 的使用"></a>3.1  call 的使用</h4><p>回到面试题第一题，我们使用「 call 」进行显式绑定</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;<span class="hljs-keyword">var</span> obj = &#123;  a :<span class="hljs-number">2</span>,  foo:foo&#125;<span class="hljs-keyword">var</span> bar =obj.fooobj.foo() <span class="hljs-comment">// 2</span>bar.call(obj) <span class="hljs-comment">//2</span></code></pre><p>此时两者都打印出 2 ，因为我们将 this 绑定到 obj ，打印出的即是  //obj.a  //2</p><h4 id="3-2-apply-绑定第一个参数是-this-二参是-一个数组"><a href="#3-2-apply-绑定第一个参数是-this-二参是-一个数组" class="headerlink" title="3.2 apply  绑定第一个参数是 this , 二参是 一个数组"></a>3.2 apply  绑定第一个参数是 this , 二参是 一个数组</h4><h4 id="3-3-bind-是-绑定第一个参数是-this"><a href="#3-3-bind-是-绑定第一个参数是-this" class="headerlink" title="3.3 bind 是 绑定第一个参数是 this"></a>3.3 bind 是 绑定第一个参数是 this</h4><h4 id="显式绑定总结-使用call-apply-bind-时，第一个参数是-this-，不传的话，默认为-undefined-。"><a href="#显式绑定总结-使用call-apply-bind-时，第一个参数是-this-，不传的话，默认为-undefined-。" class="headerlink" title="显式绑定总结: 使用call  apply bind 时，第一个参数是 this ，不传的话，默认为 undefined  。"></a>显式绑定总结: 使用call  apply bind 时，第一个参数是 this ，不传的话，默认为 undefined  。</h4><h3 id="4-new-绑定"><a href="#4-new-绑定" class="headerlink" title="4. new 绑定"></a>4. new 绑定</h3><h5 id="使用-new-来调用函数，-到底做了什么-？"><a href="#使用-new-来调用函数，-到底做了什么-？" class="headerlink" title="使用 new 来调用函数， 到底做了什么 ？"></a>使用 new 来调用函数， 到底做了什么 ？</h5><ul><li><ol><li>创建一个全新的对象</li></ol></li><li><ol start="2"><li>这个新对象的<code>__proto__</code> 链接到 构造函数的 <code>prototype</code> </li></ol></li><li><ol start="3"><li>这个新对象会绑定到函数调用的 this</li></ol></li><li><ol start="4"><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。<pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>&#123;  <span class="hljs-keyword">this</span>.a = a &#125;<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(bar.a) <span class="hljs-comment">// 2</span></code></pre>分析： 使用 new 调用 foo() 时，我们构造一个对象并把它绑定到 foo() 调用的 <code>this</code> 上</li></ol></li></ul><p>####new 绑定总结：  new 绑定中 this 绑定的就是新生成的对象</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.「 箭头函数 」内的 <code>this</code> 就是外面的 <code>this</code>  ，外面的 <code>this</code> 是啥看下面四条</p><p>2.「 <code>new</code> 绑定 」函数是否在 <code>new</code> 中调用 ？ 如果是 <code>this</code> 绑定的即是 新创建的对象。<br><code>var bar = new foo()</code></p><p>3.「 显式绑定 」函数是否通过 call 、apply、 bind 绑定？<code>this</code> 绑定的时第一个参数<br><code>var bar = foo.call(obj)</code></p><p>4.「 隐式绑定 」 函数是否在某个上下文中调用？ 是的话，<code>this</code> 绑定的是那个上下文对象<br><code>var bar =  obj.foo()</code></p><p>5.「 默认绑定」如果都不是，那么就是默认绑定。严格模式绑定到 <code>undefined</code> ，否则绑定到 全局对象<br><code>var bar = foo()</code></p><p><strong>后记</strong></p><p>你要是看不懂我也没办法了，我的修为都在这了。。。。</p><p>文章为个人总结，不足之处还请私信。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux 简单使用</title>
    <link href="/2020/04/17/redux%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/04/17/redux%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p><strong>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> store = createStore(counter);</code></pre><ol><li><p>state <code>const state = store.getState()</code></p><p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。<br>你知道 State，就知道 View 是什么样，反之亦然。</p></li><li><p>dispatch</p><p>store.dispatch() 接受一个 Action 对象，将它分发出去</p></li><li><p>subscribe</p><p>Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p><p>store.subscribe 方法返回一个函数，调用这个函数就可以解除监听。</p></li></ol><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p><strong>描述发生了什么</strong></p><pre><code class="hljs plain">&#123;  type: &quot;ADD&quot;;&#125;</code></pre><h2 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h2><p><strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</strong></p><p><strong>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) </span>&#123;  <span class="hljs-keyword">switch</span> (action.type) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">"ADD"</span>:      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;    <span class="hljs-keyword">case</span> <span class="hljs-string">"MINUS"</span>:      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span> state;  &#125;&#125;</code></pre><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>首先，用户发出 Action。</p><p><code>store.dispatch(action);</code></p><p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。<br>Reducer 会返回新的 State 。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> nextState = counter(previousState, action);</code></pre><p>State 一旦有变化，Store 就会调用监听函数。</p><p>// 设置监听函数<br>结合 React 的 hooks 可以更新数据</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [number, setNumber] = useState(store.getState());store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setNumber(store.getState()));</code></pre><p><a href="https://codesandbox.io/s/ts-redux-l2r9n?file=/src/App.tsx" target="_blank" rel="noopener">加减示例</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>React Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
